<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java反射技术</title>
      <link href="/2020/02/11/java-fan-she-ji-zhu/"/>
      <url>/2020/02/11/java-fan-she-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><ol><li>Junit单元测试</li><li>反射</li><li>注解</li></ol><h2 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h2><ul><li><p>测试分类</p><ol><li>黑盒测试:不需要写代码,给输入值,看程序是否能够输出期望的值.</li><li>白盒测试:</li></ol></li><li><p>Junit使用:白盒测试</p><ul><li><p>步骤:</p><ol><li>定义一个测试类(测试用例)<ul><li>建议:<ul><li>测试类名: 被检测的类名Test  CalculatorTest</li><li>包名: xxx.xxx.xx.test    cn.itcast.test</li></ul></li></ul></li><li>定义测试方法:可以独立运行<ul><li>建议:<ul><li>方法名:test测试的方法名    testAdd()</li><li>返回值: void</li><li>参数列表: 空参</li></ul></li></ul></li><li>给方法加Test</li><li>导入junit方法的依赖环境</li></ol></li><li><p>判定结果, 而不是输出结果:</p><ul><li>红色: 失败</li><li>绿色: 成功</li><li>一般我们会使用断言操作来处理结果<ul><li>Assert.assertEquals(期望的结果, 运算的结果);</li></ul></li></ul></li><li><p>补充</p><ul><li>@Before:<ul><li>修饰的方法会在测试方法之前被自动执行.</li></ul></li><li>@After:<ul><li>修饰的方法会在测试方法执行之后自动被执行.</li></ul></li></ul></li></ul></li></ul><h2 id="反射-框架设置的灵魂"><a href="#反射-框架设置的灵魂" class="headerlink" title="反射 : 框架设置的灵魂"></a>反射 : 框架设置的灵魂</h2><ul><li><p>框架: 半成品软件. 可以在框架的基础上进行软件开发, 简化编码.</p></li><li><p>反射: 将类的各个组成部分封装成其他对象,这就是反射机制.</p><ul><li>好处:<ol><li>可以在程序运行过程中,操作这些对象.</li><li>可以解耦, 提高程序的可扩展性.</li></ol></li></ul></li><li><p>获取Class对象的方式：</p><ol><li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象<ul><li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li></ul></li><li>类名.class：通过类名的属性class获取<ul><li>多用于参数的传递</li></ul></li><li>对象.getClass()：getClass()方法在Object类中定义着。<ul><li>多用于对象的获取字节码的方式</li></ul></li></ol><ul><li>结论：<br>同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</li></ul></li></ul><p><img src="1.jpg" alt=""></p><ul><li><p>Class对象功能：</p><ul><li><p>获取功能：</p><ol><li><p>获取成员变量们</p><ul><li>Field[] getFields() ：获取所有public修饰的成员变量</li><li>Field getField(String name)   获取指定名称的 public修饰的成员变量</li><li>Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</li><li>Field getDeclaredField(String name)</li></ul></li><li><p>获取构造方法们</p><ul><li><p>Constructor&lt;?&gt;[] getConstructors()</p></li><li><p>Constructor<t> getConstructor(类&lt;?&gt;… parameterTypes)</t></p></li><li><p>Constructor<t> getDeclaredConstructor(类&lt;?&gt;… parameterTypes)</t></p></li><li><p>Constructor&lt;?&gt;[] getDeclaredConstructors()</p></li></ul></li><li><p>获取成员方法们：</p><ul><li><p>Method[] getMethods()</p></li><li><p>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)</p></li><li><p>Method[] getDeclaredMethods()</p></li><li><p>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)</p></li></ul></li><li><p>获取全类名</p><ul><li>String getName()</li></ul></li></ol></li></ul></li><li><p>Field:成员变量</p><ul><li>操作:<ol><li>设置值<ul><li>void set(Object obj, Object value)</li></ul></li><li>获取值<ul><li>get(Object obj)</li></ul></li><li>忽略访问权限修饰符的安全检查<ul><li>d.setAccessible(true): 暴力反射</li></ul></li></ol></li></ul></li><li><p>Constructor:构造方法</p><ul><li>创建对象:<ul><li>T newInstance(Object… initargs)</li><li>如果使用空参数构造方法创建对象,操作可以简化: Class对象的newInstance();</li></ul></li></ul></li><li><p>Method:方法对象</p><ul><li>执行方法:<ul><li>Object invoke(Object obj, Object… args)</li></ul></li><li>获取方法名称<ul><li>String getName:获取方法名</li></ul></li></ul></li><li><p>案例:</p><ul><li>需求:写一个”框架”,不能改变该类的任何代码的前提下.可以创建任意类的对象,可以执行任意方法<ul><li>实现:<ol><li>配置文件</li><li>反射</li></ol></li><li>步骤:<ol start="3"><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法</li></ol></li></ul></li></ul></li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解:"></a>注解:</h2><ul><li><p>概念: 说明程序的. 给计算机看的</p></li><li><p>概念描述:</p><ul><li>JDK1.5之后的新特性</li><li>说明程序的</li><li>使用注解: @注解名称</li></ul></li><li><p>注释: 用文字描述程序. 给程序员看的</p></li><li><p>JDK中预定义的一些注解</p><ul><li><p>@Override: 检测被该注解标注的方法是否是继承自父类(接口)的.</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnoDemo02</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>@Deprecated: 将该注解标注的内容,表示已过时.<br><img src="2.jpg" alt=""></p></li><li><p>@SuppressWarnings: 压制警告</p><ul><li>一般传递参数all @SuppressWarnings(“all”)</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 压制所有的警告</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnoDemo02</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Deprecated</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 有缺陷</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 替代show1方法</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>自定义注解</p><ul><li><p>格式:</p><pre class="line-numbers language-java"><code class="language-java">  <span class="token comment" spellcheck="true">// 元注解</span>  <span class="token keyword">public</span> @<span class="token keyword">interface</span> 注解名称<span class="token punctuation">{</span>      属性列表<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过查看系统内置注解格式, 自己定义注解</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 自己定义一个MyAnno注解</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">MyAnno</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>本质: 注解本质上就是一个接口,该接口默认继承<br><img src="3.jpg" alt=""><br>Annotation</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyAnno</span> <span class="token keyword">extends</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Annotation</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>属性: 接口中的抽象方法</p><ul><li><p>要求:</p><ol><li><p>属性的返回值类型有下列取值</p><ul><li><p>基本数据类型</p></li><li><p>String</p></li><li><p>枚举</p></li><li><p>注解</p></li><li><p>以上类型的数组</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">MyAnno</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 基本数据类型</span>  <span class="token keyword">int</span> <span class="token function">show1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  String <span class="token function">show2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// String类型</span>  Person <span class="token function">per</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 枚举</span>  MyAnno2 <span class="token function">anno2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注解</span>  String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">strs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数组</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>定义了属性, 在使用时需要给属性赋值</p><ol><li>如果定义属性时, 使用default关键字给属性默认初始化值,则使用注解时, 可以不进行属性的赋值.</li><li>如果只有一个属性需要赋值, 并且属性的名称是value, 则value可以省略, 直接定义值即可.</li><li>数组赋值时, 值使用{}包裹. 如果数组中只有一个值, 则{}可以省略.</li></ol></li></ol></li></ul></li></ul></li></ul><ul><li><p>元注解: 用于描述注解的注解</p><ul><li>@Target: 描述注解能够作用的位置<ul><li>ElementType取值:<ul><li>TYPE: 可以作用于类上</li><li>METHOD: 作用于方法上</li><li>FLELD: 可以作用于子成员变量上</li></ul></li></ul></li><li>@Retention: 描述注解被保留的阶段<ul><li>@Retention(RetentionPolicy.RUNTIME): 当前被描述的注解,会保留到class字节码文件中, 并被JVM读取到.</li></ul></li><li>@Documented: 描述注解是否被抽取到api文档中</li><li>@Inherited: 描述注解是否被子类继承</li></ul></li><li><p>在程序中使用(解析)注解: 获取注解中定义的属性值</p><ol><li><p>获取注解定义的位置的对象 (Class, Method, Field)</p></li><li><p>获取指定的注解</p><ul><li><p>getAnnotation(Class)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 其实就是在内存中生成了一个该注解接口的子类实现对象</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Pro</span> <span class="token punctuation">{</span>      String <span class="token function">className</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token string">"cn.itcast.annotation.Demo01"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      String <span class="token function">methodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token string">"show"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>调用注解中的抽象方法来获取配置的属性值</p></li></ol></li></ul><ul><li>小结:<ol><li>以后大多数时候, 我们会使用注解, 而不是自定义注解</li><li>注解给谁用?<ol><li>编译器</li><li>给解析程序用</li><li>注解不是我们程序的一部分, 可以理解为一个标签.</li></ol></li></ol></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
